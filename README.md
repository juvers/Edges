### EDGES

###### TASK
> ######  Using the GitHub API, write a program that returns the authors and hashes of most recent N commits for the top M repositories by star count in a language L.
---

###### OUTPUT: 

<pre>
` {
"commit_count": 50,
"repo_count": 20,
"results": [{
    "repository_name": "..",
    "Star_count": 543,
    "authors": [{
        "Name": "...",
        "commit_hash": "..."
    }]
}]
} `
</pre>

---

###### I. Assumptions
1. Integrity of data from endpoint is guaranteed
2. Resolving the data shape is paramount such that methods and stack are secondary.
3. Github PAT other than that used by the developer will be generated by reviewer to explore project. *(However a backup PAT can be made available for use)*.
   
###### II. Unit Test Cases
N/A

######  III. Technology
- express
- graphql
- express-graphql
- fetch-node
- babel

###### IV. Directory Structure
<a id="parent-directory"></a>
-  Parent Directory

<pre>
.
├── .babelrc
├── .env
├── .git
├── .gitignore
├── README.md
├── node_modules
├── package.json
├── src
└── yarn.lock 
</pre>

- App Directory
<pre>
.
├── app.js
├── config
│   └── index.js
├── graphql
│   ├── schema.js
│   └── task.js
├── http
│   ├── generate.js
│   └── index.js
└── server.js
</pre>

###### V. Instructions on how to run the program: ==Note #6==
1. Run `git clone https://github.com/juvers/edges.git` or download zipped folder (and unzip).
2. Ensure node is already installed. You can visit [https://nodejs.org/en/download/)](https://nodejs.org/en/download/)
3. Install yarn through the npm package manager that accompanies node `npm install --global yarn`
4. Once inside folder run `yarn install`
5. Since the endpoint for this project is  `https://api.github.com/graphql` authentication is required to communicate with the GraphQL server. Therefore create PAT(personal access token) as follows: 
  a. `Settings > Developer Settings > Personal access tokens > Generate new token`
  b. Match the follow scopes behavior when creating PAT 
   <pre>
      user 
      public_repo
      repo
      repo_deployment
      repo:status
      read:repo_hook
      read:org
      read:public_key
      read:gpg_key
   </pre>
6. Create a .env file as shown in the [parent directory structure above](#parent-directory) and paste the token in the .env file as follows: `TOKEN='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'`
  ==Remember to replace the token with your own token as this is a sample.== 

7. Run `yarn start`
8. Should you get error such as this `{"message":"Bad credentials","documentation_url":"https://docs.github.com/graphql"}`
  check the PAT used to ensure is properly generated. A backup PAT can be made available by the developer if all else fail.
  f. If app is running correctly query variables can be explored at `src/graphql/task.js`

###### VI. Design Ardor
1. Javascript was opted for as the language of design because it offers the great advantage of writing in single langauge on both client and server.
2. Babel transpiler was used to enable writing in ES6 and ES7 to keep some consistency in modularization of client and server syntax
3. Separation of concerns by severing main bootstrapping file (containing all server config) from entry point(which imports server config file to run the app) file to facilitate ease of unit tests
4. Cors middleware was used to give server control over which domain(authority), scheme or port can access resources generated. Whilst for development purposes only * was used, in production only trusted origins are recommended. 
5. Utility methods were defined such as endpoint to check if the API is up and running, and utility methods to change the app port and to start listening on the configured port.
6. GraphQL used to save expensive resource commutation which is great for mobile and upholds the principle of least privilege and also has a web interface to interact with our GraphQL API, which shows the schema, available queries/mutations and has autocomplete capabilities.
7. Node-fetch was used as it is by far the smallest sized request client zipped less than 300 bytes.


###### VII. Recommendations for Project Completeness
1. Use Type System as the shape of a GraphQL query closely matches the result, which gives more predictability of what the query will return without knowing that much about the server. 
2. Build schema with the GraphQLSchema over buildSchema  as buildSchema rather takes a schema in SDL (schema definition language) and returns a GraphQLSchema object which is an optimization less. It also cannot specify resolve functions for individual fields, impossible to use Unions and Interfaces and cannot utilize custom scalars.

3. Use a Graph Leveler to minimize overhead and clean up edges and nodes with other expansive nesting.
4. To allow for better analytics population information should be gathered to use measures of central tendency and variability(dispersion) which empowers probability distribution. 
5. Plug in the user interface with graphical.
6. Build a client side to allow friendly interaction with app
7. Run unit tests 
